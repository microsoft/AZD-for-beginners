# ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå”èª¿ãƒ‘ã‚¿ãƒ¼ãƒ³

â±ï¸ **æ¨å®šæ™‚é–“**: 60-75åˆ† | ğŸ’° **æ¨å®šã‚³ã‚¹ãƒˆ**: ~$100-300/æœˆ | â­ **è¤‡é›‘åº¦**: ä¸Šç´š

**ğŸ“š å­¦ç¿’ãƒ‘ã‚¹:**
- â† å‰: [ã‚­ãƒ£ãƒ‘ã‚·ãƒ†ã‚£ãƒ—ãƒ©ãƒ³ãƒ‹ãƒ³ã‚°](capacity-planning.md) - ãƒªã‚½ãƒ¼ã‚¹ã®ã‚µã‚¤ã‚ºè¨­å®šã¨ã‚¹ã‚±ãƒ¼ãƒªãƒ³ã‚°æˆ¦ç•¥
- ğŸ¯ **ç¾åœ¨åœ°**: ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå”èª¿ãƒ‘ã‚¿ãƒ¼ãƒ³ (ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ã€é€šä¿¡ã€çŠ¶æ…‹ç®¡ç†)
- â†’ æ¬¡: [SKUé¸æŠ](sku-selection.md) - é©åˆ‡ãªAzureã‚µãƒ¼ãƒ“ã‚¹ã®é¸æŠ
- ğŸ  [ã‚³ãƒ¼ã‚¹ãƒ›ãƒ¼ãƒ ](../../README.md)

---

## å­¦ã¹ã‚‹ã“ã¨

ã“ã®ãƒ¬ãƒƒã‚¹ãƒ³ã‚’å®Œäº†ã™ã‚‹ã“ã¨ã§ã€ä»¥ä¸‹ã‚’å­¦ã¹ã¾ã™:
- **ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£**ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ãã®ä½¿ç”¨ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’ç†è§£ã™ã‚‹
- **ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³**ã‚’å®Ÿè£…ã™ã‚‹ (é›†ä¸­å‹ã€åˆ†æ•£å‹ã€éšå±¤å‹)
- **ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé€šä¿¡**æˆ¦ç•¥ã‚’è¨­è¨ˆã™ã‚‹ (åŒæœŸå‹ã€éåŒæœŸå‹ã€ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•å‹)
- åˆ†æ•£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–“ã§ã®**å…±æœ‰çŠ¶æ…‹**ã‚’ç®¡ç†ã™ã‚‹
- Azureä¸Šã§**ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ **ã‚’ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹
- å®Ÿéš›ã®AIã‚·ãƒŠãƒªã‚ªã«**å”èª¿ãƒ‘ã‚¿ãƒ¼ãƒ³**ã‚’é©ç”¨ã™ã‚‹
- åˆ†æ•£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ ã‚’ç›£è¦–ã—ãƒ‡ãƒãƒƒã‚°ã™ã‚‹

## ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå”èª¿ãŒé‡è¦ãªç†ç”±

### é€²åŒ–: ã‚·ãƒ³ã‚°ãƒ«ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‹ã‚‰ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¸

**ã‚·ãƒ³ã‚°ãƒ«ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ (ã‚·ãƒ³ãƒ—ãƒ«):**
```
User â†’ Agent â†’ Response
```
- âœ… ç†è§£ã¨å®Ÿè£…ãŒç°¡å˜
- âœ… å˜ç´”ãªã‚¿ã‚¹ã‚¯ã«ã¯é«˜é€Ÿ
- âŒ å˜ä¸€ãƒ¢ãƒ‡ãƒ«ã®èƒ½åŠ›ã«åˆ¶é™ã•ã‚Œã‚‹
- âŒ è¤‡é›‘ãªã‚¿ã‚¹ã‚¯ã‚’ä¸¦åˆ—åŒ–ã§ããªã„
- âŒ å°‚é–€æ€§ãŒãªã„

**ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ  (é«˜åº¦):**
```
           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
           â”‚ Orchestratorâ”‚
           â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚         â”‚         â”‚
    â”Œâ”€â”€â”€â–¼â”€â”€â”  â”Œâ”€â”€â–¼â”€â”€â”€â”  â”Œâ”€â”€â–¼â”€â”€â”€â”€â”
    â”‚Agent1â”‚  â”‚Agent2â”‚  â”‚Agent3 â”‚
    â”‚(Plan)â”‚  â”‚(Code)â”‚  â”‚(Review)â”‚
    â””â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”˜
```
- âœ… ç‰¹å®šã®ã‚¿ã‚¹ã‚¯ã«ç‰¹åŒ–ã—ãŸã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
- âœ… ä¸¦åˆ—å®Ÿè¡Œã«ã‚ˆã‚‹é«˜é€ŸåŒ–
- âœ… ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åŒ–ã•ã‚Œã€ä¿å®ˆãŒå®¹æ˜“
- âœ… è¤‡é›‘ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã«å¯¾å¿œå¯èƒ½
- âš ï¸ å”èª¿ãƒ­ã‚¸ãƒƒã‚¯ãŒå¿…è¦

**ä¾‹ãˆ**: ã‚·ãƒ³ã‚°ãƒ«ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ã™ã¹ã¦ã®ã‚¿ã‚¹ã‚¯ã‚’1äººã§è¡Œã†ã‚ˆã†ãªã‚‚ã®ã€‚ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯ã€ç ”ç©¶è€…ã€ã‚³ãƒ¼ãƒ€ãƒ¼ã€ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼ã€ãƒ©ã‚¤ã‚¿ãƒ¼ãªã©ã€å°‚é–€ã‚¹ã‚­ãƒ«ã‚’æŒã¤ãƒãƒ¼ãƒ ãŒå”åŠ›ã—ã¦ä½œæ¥­ã™ã‚‹ã‚ˆã†ãªã‚‚ã®ã€‚

---

## åŸºæœ¬çš„ãªå”èª¿ãƒ‘ã‚¿ãƒ¼ãƒ³

### ãƒ‘ã‚¿ãƒ¼ãƒ³1: é †æ¬¡å”èª¿ (è²¬ä»»ã®é€£é–)

**ä½¿ç”¨ã™ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°**: ã‚¿ã‚¹ã‚¯ãŒç‰¹å®šã®é †åºã§å®Œäº†ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã€å„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒå‰ã®å‡ºåŠ›ã‚’åŸºã«ä½œæ¥­ã™ã‚‹å ´åˆã€‚

```mermaid
sequenceDiagram
    participant User
    participant Orchestrator
    participant Agent1 as ãƒªã‚µãƒ¼ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    participant Agent2 as ãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    participant Agent3 as ç·¨é›†ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ
    
    User->>Orchestrator: "AIã«ã¤ã„ã¦ã®è¨˜äº‹ã‚’æ›¸ã„ã¦ãã ã•ã„"
    Orchestrator->>Agent1: ãƒˆãƒ”ãƒƒã‚¯ã‚’ãƒªã‚µãƒ¼ãƒ
    Agent1-->>Orchestrator: ãƒªã‚µãƒ¼ãƒçµæœ
    Orchestrator->>Agent2: ä¸‹æ›¸ãã‚’ä½œæˆ (ãƒªã‚µãƒ¼ãƒã‚’ä½¿ç”¨)
    Agent2-->>Orchestrator: è¨˜äº‹ã®ä¸‹æ›¸ã
    Orchestrator->>Agent3: ç·¨é›†ã¨æ”¹å–„
    Agent3-->>Orchestrator: æœ€çµ‚è¨˜äº‹
    Orchestrator-->>User: ç£¨ã‹ã‚ŒãŸè¨˜äº‹
    
    Note over User,Agent3: é †æ¬¡: å„ã‚¹ãƒ†ãƒƒãƒ—ã¯å‰ã®ã‚¹ãƒ†ãƒƒãƒ—ã‚’å¾…ã¤
```
**åˆ©ç‚¹:**
- âœ… ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼ãŒæ˜ç¢º
- âœ… ãƒ‡ãƒãƒƒã‚°ãŒå®¹æ˜“
- âœ… å®Ÿè¡Œé †åºãŒäºˆæ¸¬å¯èƒ½

**åˆ¶é™:**
- âŒ é…ã„ (ä¸¦åˆ—å‡¦ç†ãªã—)
- âŒ 1ã¤ã®å¤±æ•—ãŒå…¨ä½“ã‚’ãƒ–ãƒ­ãƒƒã‚¯
- âŒ ç›¸äº’ä¾å­˜ã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†ã§ããªã„

**ä½¿ç”¨ä¾‹:**
- ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä½œæˆãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ (èª¿æŸ» â†’ åŸ·ç­† â†’ ç·¨é›† â†’ å…¬é–‹)
- ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ (è¨ˆç”» â†’ å®Ÿè£… â†’ ãƒ†ã‚¹ãƒˆ â†’ ãƒ‡ãƒ—ãƒ­ã‚¤)
- ãƒ¬ãƒãƒ¼ãƒˆç”Ÿæˆ (ãƒ‡ãƒ¼ã‚¿åé›† â†’ åˆ†æ â†’ å¯è¦–åŒ– â†’ è¦ç´„)

---

### ãƒ‘ã‚¿ãƒ¼ãƒ³2: ä¸¦åˆ—å”èª¿ (ãƒ•ã‚¡ãƒ³ã‚¢ã‚¦ãƒˆ/ãƒ•ã‚¡ãƒ³ã‚¤ãƒ³)

**ä½¿ç”¨ã™ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°**: ç‹¬ç«‹ã—ãŸã‚¿ã‚¹ã‚¯ãŒåŒæ™‚ã«å®Ÿè¡Œã§ãã€çµæœã‚’æœ€å¾Œã«çµ±åˆã™ã‚‹å ´åˆã€‚

```mermaid
graph TB
    User[ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒªã‚¯ã‚¨ã‚¹ãƒˆ]
    Orchestrator[ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼]
    Agent1[åˆ†æã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ]
    Agent2[èª¿æŸ»ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ]
    Agent3[ãƒ‡ãƒ¼ã‚¿ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ]
    Aggregator[çµæœé›†ç´„å™¨]
    Response[çµåˆã•ã‚ŒãŸå¿œç­”]
    
    User --> Orchestrator
    Orchestrator --> Agent1
    Orchestrator --> Agent2
    Orchestrator --> Agent3
    Agent1 --> Aggregator
    Agent2 --> Aggregator
    Agent3 --> Aggregator
    Aggregator --> Response
    
    style Orchestrator fill:#2196F3,stroke:#1976D2,stroke-width:3px,color:#fff
    style Aggregator fill:#4CAF50,stroke:#388E3C,stroke-width:3px,color:#fff
```
**åˆ©ç‚¹:**
- âœ… é«˜é€Ÿ (ä¸¦åˆ—å®Ÿè¡Œ)
- âœ… ãƒ•ã‚©ãƒ¼ãƒ«ãƒˆãƒˆãƒ¬ãƒ©ãƒ³ãƒˆ (éƒ¨åˆ†çš„ãªçµæœãŒè¨±å®¹ã•ã‚Œã‚‹)
- âœ… æ°´å¹³ã‚¹ã‚±ãƒ¼ãƒ«å¯èƒ½

**åˆ¶é™:**
- âš ï¸ çµæœãŒé †ä¸åŒã§åˆ°ç€ã™ã‚‹å¯èƒ½æ€§
- âš ï¸ é›†ç´„ãƒ­ã‚¸ãƒƒã‚¯ãŒå¿…è¦
- âš ï¸ çŠ¶æ…‹ç®¡ç†ãŒè¤‡é›‘

**ä½¿ç”¨ä¾‹:**
- è¤‡æ•°ã‚½ãƒ¼ã‚¹ã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿åé›† (API + ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ + ã‚¦ã‚§ãƒ–ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ”ãƒ³ã‚°)
- ç«¶åˆåˆ†æ (è¤‡æ•°ãƒ¢ãƒ‡ãƒ«ãŒè§£ã‚’ç”Ÿæˆã—ã€æœ€é©ãªã‚‚ã®ã‚’é¸æŠ)
- ç¿»è¨³ã‚µãƒ¼ãƒ“ã‚¹ (è¤‡æ•°è¨€èªã¸ã®åŒæ™‚ç¿»è¨³)

---

### ãƒ‘ã‚¿ãƒ¼ãƒ³3: éšå±¤å‹å”èª¿ (ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼-ãƒ¯ãƒ¼ã‚«ãƒ¼)

**ä½¿ç”¨ã™ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°**: ã‚µãƒ–ã‚¿ã‚¹ã‚¯ã‚’å«ã‚€è¤‡é›‘ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã§ã€å§”ä»»ãŒå¿…è¦ãªå ´åˆã€‚

```mermaid
graph TB
    Master[ãƒã‚¹ã‚¿ãƒ¼ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼]
    Manager1[ãƒªã‚µãƒ¼ãƒãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼]
    Manager2[ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼]
    W1[ã‚¦ã‚§ãƒ–ã‚¹ã‚¯ãƒ¬ã‚¤ãƒ‘ãƒ¼]
    W2[ãƒšãƒ¼ãƒ‘ãƒ¼ã‚¢ãƒŠãƒ©ã‚¤ã‚¶ãƒ¼]
    W3[ãƒ©ã‚¤ã‚¿ãƒ¼]
    W4[ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼]
    
    Master --> Manager1
    Master --> Manager2
    Manager1 --> W1
    Manager1 --> W2
    Manager2 --> W3
    Manager2 --> W4
    
    style Master fill:#FF9800,stroke:#F57C00,stroke-width:3px,color:#fff
    style Manager1 fill:#2196F3,stroke:#1976D2,stroke-width:2px,color:#fff
    style Manager2 fill:#2196F3,stroke:#1976D2,stroke-width:2px,color:#fff
```
**åˆ©ç‚¹:**
- âœ… è¤‡é›‘ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã«å¯¾å¿œ
- âœ… ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«åŒ–ã•ã‚Œã€ä¿å®ˆãŒå®¹æ˜“
- âœ… è²¬ä»»ç¯„å›²ãŒæ˜ç¢º

**åˆ¶é™:**
- âš ï¸ ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ãŒè¤‡é›‘
- âš ï¸ é«˜ã„ãƒ¬ã‚¤ãƒ†ãƒ³ã‚·ãƒ¼ (è¤‡æ•°ã®å”èª¿ãƒ¬ã‚¤ãƒ¤ãƒ¼)
- âš ï¸ é«˜åº¦ãªã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãŒå¿…è¦

**ä½¿ç”¨ä¾‹:**
- ä¼æ¥­æ–‡æ›¸å‡¦ç† (åˆ†é¡ â†’ ãƒ«ãƒ¼ãƒ†ã‚£ãƒ³ã‚° â†’ å‡¦ç† â†’ ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–)
- å¤šæ®µéšãƒ‡ãƒ¼ã‚¿ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ (å–ã‚Šè¾¼ã¿ â†’ ã‚¯ãƒªãƒ¼ãƒ³ â†’ å¤‰æ› â†’ åˆ†æ â†’ ãƒ¬ãƒãƒ¼ãƒˆ)
- è¤‡é›‘ãªè‡ªå‹•åŒ–ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ (è¨ˆç”» â†’ ãƒªã‚½ãƒ¼ã‚¹å‰²ã‚Šå½“ã¦ â†’ å®Ÿè¡Œ â†’ ç›£è¦–)

---

### ãƒ‘ã‚¿ãƒ¼ãƒ³4: ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•å‹å”èª¿ (ãƒ‘ãƒ–ãƒªãƒƒã‚·ãƒ¥-ã‚µãƒ–ã‚¹ã‚¯ãƒ©ã‚¤ãƒ–)

**ä½¿ç”¨ã™ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°**: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒã‚¤ãƒ™ãƒ³ãƒˆã«åå¿œã—ã€ç–çµåˆãŒæ±‚ã‚ã‚‰ã‚Œã‚‹å ´åˆã€‚

```mermaid
sequenceDiagram
    participant Agent1 as ãƒ‡ãƒ¼ã‚¿åé›†è€…
    participant EventBus as Azure Service Bus
    participant Agent2 as åˆ†æè€…
    participant Agent3 as é€šçŸ¥è€…
    participant Agent4 as ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–æ‹…å½“è€…
    
    Agent1->>EventBus: ç™ºè¡Œ "ãƒ‡ãƒ¼ã‚¿å—ä¿¡" ã‚¤ãƒ™ãƒ³ãƒˆ
    EventBus->>Agent2: è³¼èª­: ãƒ‡ãƒ¼ã‚¿ã‚’åˆ†æã™ã‚‹
    EventBus->>Agent3: è³¼èª­: é€šçŸ¥ã‚’é€ä¿¡ã™ã‚‹
    EventBus->>Agent4: è³¼èª­: ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã™ã‚‹
    
    Note over Agent1,Agent4: ã™ã¹ã¦ã®è³¼èª­è€…ã¯ç‹¬ç«‹ã—ã¦å‡¦ç†ã‚’è¡Œã†
    
    Agent2->>EventBus: ç™ºè¡Œ "åˆ†æå®Œäº†" ã‚¤ãƒ™ãƒ³ãƒˆ
    EventBus->>Agent3: è³¼èª­: åˆ†æãƒ¬ãƒãƒ¼ãƒˆã‚’é€ä¿¡ã™ã‚‹
```
**åˆ©ç‚¹:**
- âœ… ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–“ã®ç–çµåˆ
- âœ… æ–°ã—ã„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®è¿½åŠ ãŒå®¹æ˜“ (ã‚µãƒ–ã‚¹ã‚¯ãƒ©ã‚¤ãƒ–ã™ã‚‹ã ã‘)
- âœ… éåŒæœŸå‡¦ç†
- âœ… ãƒ¬ã‚¸ãƒªã‚¨ãƒ³ãƒˆ (ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®æ°¸ç¶šæ€§)

**åˆ¶é™:**
- âš ï¸ æœ€çµ‚çš„ãªä¸€è²«æ€§
- âš ï¸ ãƒ‡ãƒãƒƒã‚°ãŒè¤‡é›‘
- âš ï¸ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é †åºã®èª²é¡Œ

**ä½¿ç”¨ä¾‹:**
- ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ç›£è¦–ã‚·ã‚¹ãƒ†ãƒ  (ã‚¢ãƒ©ãƒ¼ãƒˆã€ãƒ€ãƒƒã‚·ãƒ¥ãƒœãƒ¼ãƒ‰ã€ãƒ­ã‚°)
- ãƒãƒ«ãƒãƒãƒ£ãƒãƒ«é€šçŸ¥ (ãƒ¡ãƒ¼ãƒ«ã€SMSã€ãƒ—ãƒƒã‚·ãƒ¥é€šçŸ¥ã€Slack)
- ãƒ‡ãƒ¼ã‚¿å‡¦ç†ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ (åŒã˜ãƒ‡ãƒ¼ã‚¿ã‚’è¤‡æ•°ã®æ¶ˆè²»è€…ãŒåˆ©ç”¨)

---

### ãƒ‘ã‚¿ãƒ¼ãƒ³5: åˆæ„ãƒ™ãƒ¼ã‚¹ã®å”èª¿ (æŠ•ç¥¨/ã‚¯ã‚©ãƒ¼ãƒ©ãƒ )

**ä½¿ç”¨ã™ã‚‹ã‚¿ã‚¤ãƒŸãƒ³ã‚°**: è¤‡æ•°ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‹ã‚‰ã®åˆæ„ãŒå¿…è¦ãªå ´åˆã€‚

```mermaid
graph TB
    Input[å…¥åŠ›ã‚¿ã‚¹ã‚¯]
    Agent1[ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ 1: GPT-4]
    Agent2[ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ 2: Claude]
    Agent3[ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ 3: Gemini]
    Voter[ã‚³ãƒ³ã‚»ãƒ³ã‚µã‚¹æŠ•ç¥¨è€…]
    Output[åˆæ„ã•ã‚ŒãŸå‡ºåŠ›]
    
    Input --> Agent1
    Input --> Agent2
    Input --> Agent3
    Agent1 --> Voter
    Agent2 --> Voter
    Agent3 --> Voter
    Voter --> Output
    
    style Voter fill:#9C27B0,stroke:#7B1FA2,stroke-width:3px,color:#fff
```
**åˆ©ç‚¹:**
- âœ… é«˜ç²¾åº¦ (è¤‡æ•°ã®æ„è¦‹)
- âœ… ãƒ•ã‚©ãƒ¼ãƒ«ãƒˆãƒˆãƒ¬ãƒ©ãƒ³ãƒˆ (å°‘æ•°ã®å¤±æ•—ãŒè¨±å®¹ã•ã‚Œã‚‹)
- âœ… å“è³ªä¿è¨¼ãŒçµ„ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹

**åˆ¶é™:**
- âŒ ã‚³ã‚¹ãƒˆãŒé«˜ã„ (è¤‡æ•°ã®ãƒ¢ãƒ‡ãƒ«å‘¼ã³å‡ºã—)
- âŒ é…ã„ (ã™ã¹ã¦ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’å¾…ã¤å¿…è¦ãŒã‚ã‚‹)
- âš ï¸ ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆè§£æ±ºãŒå¿…è¦

**ä½¿ç”¨ä¾‹:**
- ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãƒ¢ãƒ‡ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ (è¤‡æ•°ãƒ¢ãƒ‡ãƒ«ãŒã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼)
- ã‚³ãƒ¼ãƒ‰ãƒ¬ãƒ“ãƒ¥ãƒ¼ (è¤‡æ•°ã®ãƒªãƒ³ã‚¿ãƒ¼/ã‚¢ãƒŠãƒ©ã‚¤ã‚¶ãƒ¼)
- åŒ»ç™‚è¨ºæ–­ (è¤‡æ•°ã®AIãƒ¢ãƒ‡ãƒ«ã€å°‚é–€å®¶ã®æ¤œè¨¼)

---

## ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦

### Azureä¸Šã®å®Œå…¨ãªãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ 

```mermaid
graph TB
    User[ãƒ¦ãƒ¼ã‚¶ãƒ¼/API ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆ]
    APIM[Azure API ç®¡ç†]
    Orchestrator[ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼ ã‚µãƒ¼ãƒ“ã‚¹<br/>ã‚³ãƒ³ãƒ†ãƒŠãƒ¼ ã‚¢ãƒ—ãƒª]
    ServiceBus[Azure ã‚µãƒ¼ãƒ“ã‚¹ ãƒã‚¹<br/>ã‚¤ãƒ™ãƒ³ãƒˆ ãƒãƒ–]
    
    Agent1[ãƒªã‚µãƒ¼ãƒ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ<br/>ã‚³ãƒ³ãƒ†ãƒŠãƒ¼ ã‚¢ãƒ—ãƒª]
    Agent2[ãƒ©ã‚¤ã‚¿ãƒ¼ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ<br/>ã‚³ãƒ³ãƒ†ãƒŠãƒ¼ ã‚¢ãƒ—ãƒª]
    Agent3[ã‚¢ãƒŠãƒªã‚¹ãƒˆ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ<br/>ã‚³ãƒ³ãƒ†ãƒŠãƒ¼ ã‚¢ãƒ—ãƒª]
    Agent4[ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ<br/>ã‚³ãƒ³ãƒ†ãƒŠãƒ¼ ã‚¢ãƒ—ãƒª]
    
    CosmosDB[(Cosmos DB<br/>å…±æœ‰çŠ¶æ…‹)]
    Storage[Azure ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸<br/>ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆ]
    AppInsights[ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ ã‚¤ãƒ³ã‚µã‚¤ãƒˆ<br/>ãƒ¢ãƒ‹ã‚¿ãƒªãƒ³ã‚°]
    
    User --> APIM
    APIM --> Orchestrator
    
    Orchestrator --> ServiceBus
    ServiceBus --> Agent1
    ServiceBus --> Agent2
    ServiceBus --> Agent3
    ServiceBus --> Agent4
    
    Agent1 --> CosmosDB
    Agent2 --> CosmosDB
    Agent3 --> CosmosDB
    Agent4 --> CosmosDB
    
    Agent1 --> Storage
    Agent2 --> Storage
    Agent3 --> Storage
    Agent4 --> Storage
    
    Orchestrator -.-> AppInsights
    Agent1 -.-> AppInsights
    Agent2 -.-> AppInsights
    Agent3 -.-> AppInsights
    Agent4 -.-> AppInsights
    
    style Orchestrator fill:#FF9800,stroke:#F57C00,stroke-width:3px,color:#fff
    style ServiceBus fill:#9C27B0,stroke:#7B1FA2,stroke-width:3px,color:#fff
    style CosmosDB fill:#4CAF50,stroke:#388E3C,stroke-width:3px,color:#fff
```
**ä¸»è¦ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ:**

| ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ | ç›®çš„ | Azureã‚µãƒ¼ãƒ“ã‚¹ |
|----------------|------|---------------|
| **APIã‚²ãƒ¼ãƒˆã‚¦ã‚§ã‚¤** | ã‚¨ãƒ³ãƒˆãƒªãƒ¼ãƒã‚¤ãƒ³ãƒˆã€ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã€èªè¨¼ | API Management |
| **ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼** | ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®èª¿æ•´ | Container Apps |
| **ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚­ãƒ¥ãƒ¼** | éåŒæœŸé€šä¿¡ | Service Bus / Event Hubs |
| **ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ** | ç‰¹åŒ–å‹AIãƒ¯ãƒ¼ã‚«ãƒ¼ | Container Apps / Functions |
| **çŠ¶æ…‹ã‚¹ãƒˆã‚¢** | å…±æœ‰çŠ¶æ…‹ã€ã‚¿ã‚¹ã‚¯è¿½è·¡ | Cosmos DB |
| **ã‚¢ãƒ¼ãƒ†ã‚£ãƒ•ã‚¡ã‚¯ãƒˆã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸** | ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã€çµæœã€ãƒ­ã‚° | Blob Storage |
| **ç›£è¦–** | åˆ†æ•£ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ã€ãƒ­ã‚° | Application Insights |

---

## å‰ææ¡ä»¶

### å¿…è¦ãªãƒ„ãƒ¼ãƒ«

```bash
# Azure Developer CLI ã‚’ç¢ºèªã™ã‚‹
azd version
# âœ… æœŸå¾…å€¤: azd ãƒãƒ¼ã‚¸ãƒ§ãƒ³ 1.0.0 ä»¥ä¸Š

# Azure CLI ã‚’ç¢ºèªã™ã‚‹
az --version
# âœ… æœŸå¾…å€¤: azure-cli 2.50.0 ä»¥ä¸Š

# Docker ã‚’ç¢ºèªã™ã‚‹ (ãƒ­ãƒ¼ã‚«ãƒ«ãƒ†ã‚¹ãƒˆç”¨)
docker --version
# âœ… æœŸå¾…å€¤: Docker ãƒãƒ¼ã‚¸ãƒ§ãƒ³ 20.10 ä»¥ä¸Š
```

### Azureã®è¦ä»¶

- æœ‰åŠ¹ãªAzureã‚µãƒ–ã‚¹ã‚¯ãƒªãƒ—ã‚·ãƒ§ãƒ³
- ä»¥ä¸‹ã‚’ä½œæˆã™ã‚‹æ¨©é™:
  - Container Apps
  - Service Busåå‰ç©ºé–“
  - Cosmos DBã‚¢ã‚«ã‚¦ãƒ³ãƒˆ
  - ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‚¢ã‚«ã‚¦ãƒ³ãƒˆ
  - Application Insights

### çŸ¥è­˜ã®å‰ææ¡ä»¶

ä»¥ä¸‹ã‚’å®Œäº†ã—ã¦ã„ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™:
- [æ§‹æˆç®¡ç†](../getting-started/configuration.md)
- [èªè¨¼ã¨ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£](../getting-started/authsecurity.md)
- [ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã®ä¾‹](../../../../examples/microservices)

---

## å®Ÿè£…ã‚¬ã‚¤ãƒ‰

### ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹é€ 

```
multi-agent-system/
â”œâ”€â”€ azure.yaml                    # AZD configuration
â”œâ”€â”€ infra/
â”‚   â”œâ”€â”€ main.bicep               # Main infrastructure
â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”œâ”€â”€ servicebus.bicep     # Message queue
â”‚   â”‚   â”œâ”€â”€ cosmos.bicep         # State store
â”‚   â”‚   â”œâ”€â”€ storage.bicep        # Artifact storage
â”‚   â”‚   â””â”€â”€ monitoring.bicep     # Application Insights
â”‚   â””â”€â”€ app/
â”‚       â”œâ”€â”€ orchestrator.bicep   # Orchestrator service
â”‚       â””â”€â”€ agent.bicep          # Agent template
â””â”€â”€ src/
    â”œâ”€â”€ orchestrator/            # Orchestration logic
    â”‚   â”œâ”€â”€ app.py
    â”‚   â”œâ”€â”€ workflows.py
    â”‚   â””â”€â”€ Dockerfile
    â”œâ”€â”€ agents/
    â”‚   â”œâ”€â”€ research/            # Research agent
    â”‚   â”œâ”€â”€ writer/              # Writer agent
    â”‚   â”œâ”€â”€ analyst/             # Analyst agent
    â”‚   â””â”€â”€ reviewer/            # Reviewer agent
    â””â”€â”€ shared/
        â”œâ”€â”€ state_manager.py     # Shared state logic
        â””â”€â”€ message_handler.py   # Message handling
```

---

## ãƒ¬ãƒƒã‚¹ãƒ³1: é †æ¬¡å”èª¿ãƒ‘ã‚¿ãƒ¼ãƒ³

### å®Ÿè£…: ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ä½œæˆãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³

èª¿æŸ» â†’ åŸ·ç­† â†’ ç·¨é›† â†’ å…¬é–‹ã®é †æ¬¡ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚

### 1. AZDæ§‹æˆ

**ãƒ•ã‚¡ã‚¤ãƒ«: `azure.yaml`**

```yaml
name: content-pipeline
metadata:
  template: multi-agent-sequential@1.0.0

services:
  orchestrator:
    project: ./src/orchestrator
    language: python
    host: containerapp
  
  research-agent:
    project: ./src/agents/research
    language: python
    host: containerapp
  
  writer-agent:
    project: ./src/agents/writer
    language: python
    host: containerapp
  
  editor-agent:
    project: ./src/agents/editor
    language: python
    host: containerapp
```

### 2. ã‚¤ãƒ³ãƒ•ãƒ©: å”èª¿ç”¨Service Bus

**ãƒ•ã‚¡ã‚¤ãƒ«: `infra/core/servicebus.bicep`**

```bicep
param name string
param location string
param tags object = {}

resource serviceBusNamespace 'Microsoft.ServiceBus/namespaces@2022-10-01-preview' = {
  name: name
  location: location
  tags: tags
  sku: {
    name: 'Standard'
    tier: 'Standard'
  }
  properties: {
    minimumTlsVersion: '1.2'
  }
}

// Queue for orchestrator â†’ research agent
resource researchQueue 'Microsoft.ServiceBus/namespaces/queues@2022-10-01-preview' = {
  parent: serviceBusNamespace
  name: 'research-tasks'
  properties: {
    maxDeliveryCount: 3
    lockDuration: 'PT5M'
    deadLetteringOnMessageExpiration: true
  }
}

// Queue for research agent â†’ writer agent
resource writerQueue 'Microsoft.ServiceBus/namespaces/queues@2022-10-01-preview' = {
  parent: serviceBusNamespace
  name: 'writer-tasks'
  properties: {
    maxDeliveryCount: 3
    lockDuration: 'PT5M'
  }
}

// Queue for writer agent â†’ editor agent
resource editorQueue 'Microsoft.ServiceBus/namespaces/queues@2022-10-01-preview' = {
  parent: serviceBusNamespace
  name: 'editor-tasks'
  properties: {
    maxDeliveryCount: 3
    lockDuration: 'PT5M'
  }
}

output namespace string = serviceBusNamespace.name
output connectionString string = listKeys('${serviceBusNamespace.id}/AuthorizationRules/RootManageSharedAccessKey', serviceBusNamespace.apiVersion).primaryConnectionString
```

### 3. å…±æœ‰çŠ¶æ…‹ãƒãƒãƒ¼ã‚¸ãƒ£ãƒ¼

**ãƒ•ã‚¡ã‚¤ãƒ«: `src/shared/state_manager.py`**

```python
from azure.cosmos import CosmosClient, PartitionKey
from datetime import datetime
import os

class StateManager:
    """Manages shared state across agents using Cosmos DB"""
    
    def __init__(self):
        endpoint = os.environ['COSMOS_ENDPOINT']
        key = os.environ['COSMOS_KEY']
        
        self.client = CosmosClient(endpoint, key)
        self.database = self.client.get_database_client('agent-state')
        self.container = self.database.get_container_client('tasks')
    
    def create_task(self, task_id: str, task_type: str, input_data: dict):
        """Create a new task"""
        task = {
            'id': task_id,
            'type': task_type,
            'status': 'pending',
            'input': input_data,
            'created_at': datetime.utcnow().isoformat(),
            'steps': []
        }
        self.container.create_item(task)
        return task
    
    def update_task_step(self, task_id: str, step_name: str, result: dict):
        """Update task with completed step"""
        task = self.container.read_item(task_id, partition_key=task_id)
        
        task['steps'].append({
            'name': step_name,
            'completed_at': datetime.utcnow().isoformat(),
            'result': result
        })
        
        self.container.replace_item(task_id, task)
        return task
    
    def complete_task(self, task_id: str, final_result: dict):
        """Mark task as complete"""
        task = self.container.read_item(task_id, partition_key=task_id)
        task['status'] = 'completed'
        task['result'] = final_result
        task['completed_at'] = datetime.utcnow().isoformat()
        self.container.replace_item(task_id, task)
        return task
    
    def get_task(self, task_id: str):
        """Retrieve task state"""
        return self.container.read_item(task_id, partition_key=task_id)
```

### 4. ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼ã‚µãƒ¼ãƒ“ã‚¹

**ãƒ•ã‚¡ã‚¤ãƒ«: `src/orchestrator/app.py`**

```python
from flask import Flask, request, jsonify
from azure.servicebus import ServiceBusClient, ServiceBusMessage
import json
import uuid
import os
from shared.state_manager import StateManager

app = Flask(__name__)
state_manager = StateManager()

# ã‚µãƒ¼ãƒ“ã‚¹ãƒã‚¹æ¥ç¶š
servicebus_connection_str = os.environ['SERVICEBUS_CONNECTION_STRING']
servicebus_client = ServiceBusClient.from_connection_string(servicebus_connection_str)

@app.route('/health', methods=['GET'])
def health():
    return jsonify({'status': 'healthy', 'service': 'orchestrator'})

@app.route('/create-content', methods=['POST'])
def create_content():
    """
    Sequential workflow: Research â†’ Write â†’ Edit â†’ Publish
    """
    data = request.json
    topic = data.get('topic')
    
    if not topic:
        return jsonify({'error': 'Topic required'}), 400
    
    # çŠ¶æ…‹ã‚¹ãƒˆã‚¢ã§ã‚¿ã‚¹ã‚¯ã‚’ä½œæˆ
    task_id = str(uuid.uuid4())
    task = state_manager.create_task(
        task_id=task_id,
        task_type='content_creation',
        input_data={'topic': topic}
    )
    
    # ç ”ç©¶ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ï¼ˆæœ€åˆã®ã‚¹ãƒ†ãƒƒãƒ—ï¼‰
    sender = servicebus_client.get_queue_sender('research-tasks')
    message = ServiceBusMessage(
        body=json.dumps({
            'task_id': task_id,
            'topic': topic,
            'next_queue': 'writer-tasks'  # çµæœã‚’é€ä¿¡ã™ã‚‹å ´æ‰€
        }),
        content_type='application/json'
    )
    
    with sender:
        sender.send_messages(message)
    
    return jsonify({
        'task_id': task_id,
        'status': 'started',
        'workflow': 'sequential',
        'steps': ['research', 'write', 'edit', 'publish'],
        'message': 'Content creation pipeline initiated'
    }), 202

@app.route('/task/<task_id>', methods=['GET'])
def get_task_status(task_id):
    """Check task status"""
    try:
        task = state_manager.get_task(task_id)
        return jsonify(task)
    except Exception as e:
        return jsonify({'error': str(e)}), 404

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)
```

### 5. èª¿æŸ»ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

**ãƒ•ã‚¡ã‚¤ãƒ«: `src/agents/research/app.py`**

```python
from azure.servicebus import ServiceBusClient, ServiceBusMessage
from openai import AzureOpenAI
import json
import os
import time
from shared.state_manager import StateManager

# ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‚’åˆæœŸåŒ–ã™ã‚‹
state_manager = StateManager()
servicebus_client = ServiceBusClient.from_connection_string(
    os.environ['SERVICEBUS_CONNECTION_STRING']
)

openai_client = AzureOpenAI(
    api_key=os.environ['AZURE_OPENAI_API_KEY'],
    api_version="2024-02-01",
    azure_endpoint=os.environ['AZURE_OPENAI_ENDPOINT']
)

def process_research_task(message_data):
    """Process research request and pass to writer"""
    task_id = message_data['task_id']
    topic = message_data['topic']
    next_queue = message_data['next_queue']
    
    print(f"ğŸ”¬ Researching: {topic}")
    
    # èª¿æŸ»ã®ãŸã‚ã«Azure OpenAIã‚’å‘¼ã³å‡ºã™
    response = openai_client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "You are a research assistant. Provide comprehensive research on the given topic."},
            {"role": "user", "content": f"Research this topic thoroughly: {topic}"}
        ],
        max_tokens=1500
    )
    
    research_results = response.choices[0].message.content
    
    # çŠ¶æ…‹ã‚’æ›´æ–°ã™ã‚‹
    state_manager.update_task_step(
        task_id=task_id,
        step_name='research',
        result={'research': research_results}
    )
    
    # æ¬¡ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆï¼ˆãƒ©ã‚¤ã‚¿ãƒ¼ï¼‰ã«é€ä¿¡ã™ã‚‹
    sender = servicebus_client.get_queue_sender(next_queue)
    message = ServiceBusMessage(
        body=json.dumps({
            'task_id': task_id,
            'topic': topic,
            'research': research_results,
            'next_queue': 'editor-tasks'
        }),
        content_type='application/json'
    )
    
    with sender:
        sender.send_messages(message)
    
    print(f"âœ… Research complete for task {task_id}")

def main():
    """Listen to research queue"""
    receiver = servicebus_client.get_queue_receiver('research-tasks')
    
    print("ğŸ”¬ Research Agent started, listening for tasks...")
    
    with receiver:
        while True:
            messages = receiver.receive_messages(max_wait_time=5)
            for message in messages:
                try:
                    message_data = json.loads(str(message))
                    process_research_task(message_data)
                    receiver.complete_message(message)
                except Exception as e:
                    print(f"âŒ Error processing message: {e}")
                    receiver.abandon_message(message)

if __name__ == '__main__':
    main()
```

### 6. ãƒ©ã‚¤ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

**ãƒ•ã‚¡ã‚¤ãƒ«: `src/agents/writer/app.py`**

```python
from azure.servicebus import ServiceBusClient, ServiceBusMessage
from openai import AzureOpenAI
import json
import os
from shared.state_manager import StateManager

state_manager = StateManager()
servicebus_client = ServiceBusClient.from_connection_string(
    os.environ['SERVICEBUS_CONNECTION_STRING']
)

openai_client = AzureOpenAI(
    api_key=os.environ['AZURE_OPENAI_API_KEY'],
    api_version="2024-02-01",
    azure_endpoint=os.environ['AZURE_OPENAI_ENDPOINT']
)

def process_writing_task(message_data):
    """Write article based on research"""
    task_id = message_data['task_id']
    topic = message_data['topic']
    research = message_data['research']
    next_queue = message_data['next_queue']
    
    print(f"âœï¸ Writing article: {topic}")
    
    # Azure OpenAIã‚’å‘¼ã³å‡ºã—ã¦è¨˜äº‹ã‚’æ›¸ã
    response = openai_client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "You are a professional writer. Write engaging, well-structured articles."},
            {"role": "user", "content": f"Based on this research:\n\n{research}\n\nWrite a comprehensive article about: {topic}"}
        ],
        max_tokens=2000
    )
    
    article_draft = response.choices[0].message.content
    
    # çŠ¶æ…‹ã‚’æ›´æ–°ã™ã‚‹
    state_manager.update_task_step(
        task_id=task_id,
        step_name='writing',
        result={'draft': article_draft}
    )
    
    # ç·¨é›†è€…ã«é€ã‚‹
    sender = servicebus_client.get_queue_sender(next_queue)
    message = ServiceBusMessage(
        body=json.dumps({
            'task_id': task_id,
            'topic': topic,
            'draft': article_draft
        }),
        content_type='application/json'
    )
    
    with sender:
        sender.send_messages(message)
    
    print(f"âœ… Article draft complete for task {task_id}")

def main():
    """Listen to writer queue"""
    receiver = servicebus_client.get_queue_receiver('writer-tasks')
    
    print("âœï¸ Writer Agent started, listening for tasks...")
    
    with receiver:
        while True:
            messages = receiver.receive_messages(max_wait_time=5)
            for message in messages:
                try:
                    message_data = json.loads(str(message))
                    process_writing_task(message_data)
                    receiver.complete_message(message)
                except Exception as e:
                    print(f"âŒ Error: {e}")
                    receiver.abandon_message(message)

if __name__ == '__main__':
    main()
```

### 7. ã‚¨ãƒ‡ã‚£ã‚¿ãƒ¼ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ

**ãƒ•ã‚¡ã‚¤ãƒ«: `src/agents/editor/app.py`**

```python
from azure.servicebus import ServiceBusClient
from openai import AzureOpenAI
import json
import os
from shared.state_manager import StateManager

state_manager = StateManager()
servicebus_client = ServiceBusClient.from_connection_string(
    os.environ['SERVICEBUS_CONNECTION_STRING']
)

openai_client = AzureOpenAI(
    api_key=os.environ['AZURE_OPENAI_API_KEY'],
    api_version="2024-02-01",
    azure_endpoint=os.environ['AZURE_OPENAI_ENDPOINT']
)

def process_editing_task(message_data):
    """Edit and finalize article"""
    task_id = message_data['task_id']
    topic = message_data['topic']
    draft = message_data['draft']
    
    print(f"ğŸ“ Editing article: {topic}")
    
    # Azure OpenAIã‚’å‘¼ã³å‡ºã—ã¦ç·¨é›†ã™ã‚‹
    response = openai_client.chat.completions.create(
        model="gpt-4",
        messages=[
            {"role": "system", "content": "You are an expert editor. Improve grammar, clarity, and structure."},
            {"role": "user", "content": f"Edit and improve this article:\n\n{draft}"}
        ],
        max_tokens=2000
    )
    
    final_article = response.choices[0].message.content
    
    # ã‚¿ã‚¹ã‚¯ã‚’å®Œäº†ã¨ã—ã¦ãƒãƒ¼ã‚¯ã™ã‚‹
    state_manager.complete_task(
        task_id=task_id,
        final_result={
            'topic': topic,
            'final_article': final_article,
            'word_count': len(final_article.split())
        }
    )
    
    print(f"âœ… Article finalized for task {task_id}")

def main():
    """Listen to editor queue"""
    receiver = servicebus_client.get_queue_receiver('editor-tasks')
    
    print("ğŸ“ Editor Agent started, listening for tasks...")
    
    with receiver:
        while True:
            messages = receiver.receive_messages(max_wait_time=5)
            for message in messages:
                try:
                    message_data = json.loads(str(message))
                    process_editing_task(message_data)
                    receiver.complete_message(message)
                except Exception as e:
                    print(f"âŒ Error: {e}")
                    receiver.abandon_message(message)

if __name__ == '__main__':
    main()
```

### 8. ãƒ‡ãƒ—ãƒ­ã‚¤ã¨ãƒ†ã‚¹ãƒˆ

```bash
# åˆæœŸåŒ–ã—ã¦ãƒ‡ãƒ—ãƒ­ã‚¤ã™ã‚‹
azd init
azd up

# ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼ã®URLã‚’å–å¾—ã™ã‚‹
ORCHESTRATOR_URL=$(azd env get-values | grep ORCHESTRATOR_URL | cut -d '=' -f2 | tr -d '"')

# ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ã‚’ä½œæˆã™ã‚‹
curl -X POST $ORCHESTRATOR_URL/create-content \
  -H "Content-Type: application/json" \
  -d '{"topic": "The Future of AI in Healthcare"}'
```

**âœ… æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ›:**
```json
{
  "task_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "status": "started",
  "workflow": "sequential",
  "steps": ["research", "write", "edit", "publish"],
  "message": "Content creation pipeline initiated"
}
```

**ã‚¿ã‚¹ã‚¯é€²æ—ã®ç¢ºèª:**
```bash
TASK_ID="a1b2c3d4-e5f6-7890-abcd-ef1234567890"
curl $ORCHESTRATOR_URL/task/$TASK_ID
```

**âœ… æœŸå¾…ã•ã‚Œã‚‹å‡ºåŠ› (å®Œäº†):**
```json
{
  "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "type": "content_creation",
  "status": "completed",
  "steps": [
    {
      "name": "research",
      "completed_at": "2025-11-19T10:30:00Z",
      "result": {"research": "..."}
    },
    {
      "name": "writing",
      "completed_at": "2025-11-19T10:32:00Z",
      "result": {"draft": "..."}
    }
  ],
  "result": {
    "topic": "The Future of AI in Healthcare",
    "final_article": "...",
    "word_count": 1500
  }
}
```

---

## ãƒ¬ãƒƒã‚¹ãƒ³2: ä¸¦åˆ—å”èª¿ãƒ‘ã‚¿ãƒ¼ãƒ³

### å®Ÿè£…: ãƒãƒ«ãƒã‚½ãƒ¼ã‚¹èª¿æŸ»ã‚¢ã‚°ãƒªã‚²ãƒ¼ã‚¿ãƒ¼

è¤‡æ•°ã®ã‚½ãƒ¼ã‚¹ã‹ã‚‰åŒæ™‚ã«æƒ…å ±ã‚’åé›†ã™ã‚‹ä¸¦åˆ—ã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã—ã¾ã™ã€‚

### ä¸¦åˆ—ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼

**ãƒ•ã‚¡ã‚¤ãƒ«: `src/orchestrator/parallel_workflow.py`**

```python
from flask import Flask, request, jsonify
from azure.servicebus import ServiceBusClient, ServiceBusMessage
import json
import uuid
import os
from shared.state_manager import StateManager

app = Flask(__name__)
state_manager = StateManager()

servicebus_client = ServiceBusClient.from_connection_string(
    os.environ['SERVICEBUS_CONNECTION_STRING']
)

@app.route('/research-parallel', methods=['POST'])
def research_parallel():
    """
    Parallel workflow: Multiple agents work simultaneously
    """
    data = request.json
    query = data.get('query')
    
    task_id = str(uuid.uuid4())
    task = state_manager.create_task(
        task_id=task_id,
        task_type='parallel_research',
        input_data={
            'query': query,
            'agents': ['web', 'academic', 'news', 'social']
        }
    )
    
    # ãƒ•ã‚¡ãƒ³ã‚¢ã‚¦ãƒˆ: ã™ã¹ã¦ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«åŒæ™‚ã«é€ä¿¡
    agents = [
        ('web-research-queue', 'web'),
        ('academic-research-queue', 'academic'),
        ('news-research-queue', 'news'),
        ('social-research-queue', 'social')
    ]
    
    for queue_name, agent_type in agents:
        sender = servicebus_client.get_queue_sender(queue_name)
        message = ServiceBusMessage(
            body=json.dumps({
                'task_id': task_id,
                'query': query,
                'agent_type': agent_type,
                'result_queue': 'aggregation-queue'
            }),
            content_type='application/json'
        )
        
        with sender:
            sender.send_messages(message)
    
    return jsonify({
        'task_id': task_id,
        'status': 'started',
        'workflow': 'parallel',
        'agents_dispatched': 4,
        'message': 'Parallel research initiated'
    }), 202

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8080)
```

### é›†ç´„ãƒ­ã‚¸ãƒƒã‚¯

**ãƒ•ã‚¡ã‚¤ãƒ«: `src/agents/aggregator/app.py`**

```python
from azure.servicebus import ServiceBusClient
import json
import os
from collections import defaultdict
from shared.state_manager import StateManager

state_manager = StateManager()
servicebus_client = ServiceBusClient.from_connection_string(
    os.environ['SERVICEBUS_CONNECTION_STRING']
)

# ã‚¿ã‚¹ã‚¯ã”ã¨ã®çµæœã‚’è¿½è·¡ã™ã‚‹
task_results = defaultdict(list)
expected_agents = 4  # ã‚¦ã‚§ãƒ–ã€å­¦è¡“ã€ãƒ‹ãƒ¥ãƒ¼ã‚¹ã€ã‚½ãƒ¼ã‚·ãƒ£ãƒ«

def process_result(message_data):
    """Aggregate results from parallel agents"""
    task_id = message_data['task_id']
    agent_type = message_data['agent_type']
    result = message_data['result']
    
    # çµæœã‚’ä¿å­˜ã™ã‚‹
    task_results[task_id].append({
        'agent': agent_type,
        'data': result
    })
    
    print(f"ğŸ“Š Received result from {agent_type} agent ({len(task_results[task_id])}/{expected_agents})")
    
    # ã™ã¹ã¦ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒå®Œäº†ã—ãŸã‹ç¢ºèªã™ã‚‹ï¼ˆãƒ•ã‚¡ãƒ³ã‚¤ãƒ³ï¼‰
    if len(task_results[task_id]) == expected_agents:
        print(f"âœ… All agents completed for task {task_id}. Aggregating...")
        
        # çµæœã‚’çµåˆã™ã‚‹
        aggregated = {
            'query': message_data['query'],
            'sources': task_results[task_id],
            'summary': generate_summary(task_results[task_id])
        }
        
        # å®Œäº†ã¨ã—ã¦ãƒãƒ¼ã‚¯ã™ã‚‹
        state_manager.complete_task(task_id, aggregated)
        
        # ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—ã™ã‚‹
        del task_results[task_id]
        
        print(f"âœ… Aggregation complete for task {task_id}")

def generate_summary(results):
    """Generate summary from all sources"""
    summaries = [r['data'].get('summary', '') for r in results]
    return '\n\n'.join(summaries)

def main():
    """Listen to aggregation queue"""
    receiver = servicebus_client.get_queue_receiver('aggregation-queue')
    
    print("ğŸ“Š Aggregator started, listening for results...")
    
    with receiver:
        while True:
            messages = receiver.receive_messages(max_wait_time=5)
            for message in messages:
                try:
                    message_data = json.loads(str(message))
                    process_result(message_data)
                    receiver.complete_message(message)
                except Exception as e:
                    print(f"âŒ Error: {e}")
                    receiver.abandon_message(message)

if __name__ == '__main__':
    main()
```

**ä¸¦åˆ—ãƒ‘ã‚¿ãƒ¼ãƒ³ã®åˆ©ç‚¹:**
- âš¡ **4å€é«˜é€Ÿ** (ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒåŒæ™‚ã«å®Ÿè¡Œ)
- ğŸ”„ **ãƒ•ã‚©ãƒ¼ãƒ«ãƒˆãƒˆãƒ¬ãƒ©ãƒ³ãƒˆ** (éƒ¨åˆ†çš„ãªçµæœãŒè¨±å®¹ã•ã‚Œã‚‹)
- ğŸ“ˆ **ã‚¹ã‚±ãƒ¼ãƒ©ãƒ–ãƒ«** (ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç°¡å˜ã«è¿½åŠ å¯èƒ½)

---

## å®Ÿè·µæ¼”ç¿’

### æ¼”ç¿’1: ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå‡¦ç†ã®è¿½åŠ  â­â­ (ä¸­ç´š)

**ç›®æ¨™**: ã‚¢ã‚°ãƒªã‚²ãƒ¼ã‚¿ãƒ¼ãŒé…ã„ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’æ°¸é ã«å¾…ãŸãªã„ã‚ˆã†ã«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãƒ­ã‚¸ãƒƒã‚¯ã‚’å®Ÿè£…ã™ã‚‹ã€‚

**æ‰‹é †**:

1. **ã‚¢ã‚°ãƒªã‚²ãƒ¼ã‚¿ãƒ¼ã«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆè¿½è·¡ã‚’è¿½åŠ :**

```python
from datetime import datetime, timedelta

task_timeouts = {}  # task_id -> æœ‰åŠ¹æœŸé™

def process_result(message_data):
    task_id = message_data['task_id']
    
    # æœ€åˆã®çµæœã«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’è¨­å®š
    if task_id not in task_timeouts:
        task_timeouts[task_id] = datetime.utcnow() + timedelta(seconds=30)
    
    task_results[task_id].append({
        'agent': message_data['agent_type'],
        'data': message_data['result']
    })
    
    # å®Œäº†ã¾ãŸã¯ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ãŸã‹ç¢ºèª
    if len(task_results[task_id]) == expected_agents or \
       datetime.utcnow() > task_timeouts[task_id]:
        
        print(f"ğŸ“Š Aggregating with {len(task_results[task_id])}/{expected_agents} results")
        
        aggregated = {
            'query': message_data['query'],
            'sources': task_results[task_id],
            'completed_agents': len(task_results[task_id]),
            'timed_out': len(task_results[task_id]) < expected_agents
        }
        
        state_manager.complete_task(task_id, aggregated)
        
        # ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
        del task_results[task_id]
        del task_timeouts[task_id]
```

2. **äººå·¥çš„ãªé…å»¶ã§ãƒ†ã‚¹ãƒˆ:**

```python
# 1ã¤ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã§é…å»¶ã‚’è¿½åŠ ã—ã¦ã€å‡¦ç†ã®é…ã•ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹
import time
time.sleep(35)  # 30ç§’ã®ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’è¶…ãˆã‚‹
```

3. **ãƒ‡ãƒ—ãƒ­ã‚¤ã¨æ¤œè¨¼:**

```bash
azd deploy aggregator

# ã‚¿ã‚¹ã‚¯ã‚’é€ä¿¡ã™ã‚‹
curl -X POST $ORCHESTRATOR_URL/research-parallel \
  -H "Content-Type: application/json" \
  -d '{"query": "AI safety research"}'

# 30ç§’å¾Œã«çµæœã‚’ç¢ºèªã™ã‚‹
curl $ORCHESTRATOR_URL/task/$TASK_ID
```

**âœ… æˆåŠŸåŸºæº–:**
- âœ… ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒå®Œäº†ã—ãªãã¦ã‚‚30ç§’å¾Œã«ã‚¿ã‚¹ã‚¯ãŒå®Œäº†ã™ã‚‹
- âœ… å¿œç­”ã«éƒ¨åˆ†çš„ãªçµæœãŒå«ã¾ã‚Œã‚‹ (`"timed_out": true`)
- âœ… åˆ©ç”¨å¯èƒ½ãªçµæœãŒè¿”ã•ã‚Œã‚‹ (4ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆä¸­3ã¤)

**æ™‚é–“**: 20-25åˆ†

---

### æ¼”ç¿’2: ãƒªãƒˆãƒ©ã‚¤ãƒ­ã‚¸ãƒƒã‚¯ã®å®Ÿè£… â­â­â­ (ä¸Šç´š)

**ç›®æ¨™**: å¤±æ•—ã—ãŸã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¿ã‚¹ã‚¯ã‚’è‡ªå‹•çš„ã«ãƒªãƒˆãƒ©ã‚¤ã™ã‚‹ã€‚

**æ‰‹é †**:

1. **ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼ã«ãƒªãƒˆãƒ©ã‚¤è¿½è·¡ã‚’è¿½åŠ :**

```python
from dataclasses import dataclass
from typing import Dict

@dataclass
class RetryConfig:
    max_retries: int = 3
    backoff_seconds: int = 5

retry_counts: Dict[str, int] = {}  # message_id -> retry_count

def send_with_retry(queue_name: str, message_data: dict, retry_config: RetryConfig):
    """Send message with retry metadata"""
    message_id = message_data.get('message_id', str(uuid.uuid4()))
    message_data['message_id'] = message_id
    message_data['retry_count'] = retry_counts.get(message_id, 0)
    message_data['max_retries'] = retry_config.max_retries
    
    sender = servicebus_client.get_queue_sender(queue_name)
    message = ServiceBusMessage(
        body=json.dumps(message_data),
        content_type='application/json',
        message_id=message_id
    )
    
    with sender:
        sender.send_messages(message)
```

2. **ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã«ãƒªãƒˆãƒ©ã‚¤ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ã‚’è¿½åŠ :**

```python
def process_with_retry(message, receiver, process_func):
    """Process message with automatic retry on failure"""
    try:
        message_data = json.loads(str(message))
        
        # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å‡¦ç†ã™ã‚‹
        process_func(message_data)
        
        # æˆåŠŸ - å®Œäº†
        receiver.complete_message(message)
        
    except Exception as e:
        message_id = message.message_id
        retry_count = message_data.get('retry_count', 0)
        max_retries = message_data.get('max_retries', 3)
        
        if retry_count < max_retries:
            # å†è©¦è¡Œ: æ”¾æ£„ã—ã¦ã‚«ã‚¦ãƒ³ãƒˆã‚’å¢—ã‚„ã—ã¦å†ã‚­ãƒ¥ãƒ¼
            print(f"âš ï¸ Retry {retry_count + 1}/{max_retries} for message {message_id}")
            
            message_data['retry_count'] = retry_count + 1
            
            # é…å»¶ã‚’ã¤ã‘ã¦åŒã˜ã‚­ãƒ¥ãƒ¼ã«é€ã‚Šè¿”ã™
            time.sleep(5 * (retry_count + 1))  # æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ•
            send_with_retry(queue_name, message_data, RetryConfig())
            
            receiver.complete_message(message)  # å…ƒã®ã‚‚ã®ã‚’å‰Šé™¤ã™ã‚‹
        else:
            # æœ€å¤§å†è©¦è¡Œå›æ•°ã‚’è¶…é - ãƒ‡ãƒƒãƒ‰ãƒ¬ã‚¿ãƒ¼ã‚­ãƒ¥ãƒ¼ã«ç§»å‹•
            print(f"âŒ Max retries exceeded for message {message_id}")
            receiver.dead_letter_message(
                message,
                reason="MaxRetriesExceeded",
                error_description=str(e)
            )
```

3. **ãƒ‡ãƒƒãƒ‰ãƒ¬ã‚¿ã‚­ãƒ¥ãƒ¼ã‚’ç›£è¦–:**

```python
def monitor_dead_letters():
    """Check dead letter queue for failed messages"""
    receiver = servicebus_client.get_queue_receiver(
        'research-queue',
        sub_queue='deadletter'
    )
    
    with receiver:
        messages = receiver.receive_messages(max_wait_time=5)
        for message in messages:
            print(f"â˜ ï¸ Dead letter: {message.message_id}")
            print(f"Reason: {message.dead_letter_reason}")
            print(f"Description: {message.dead_letter_error_description}")
```

**âœ… æˆåŠŸåŸºæº–:**
- âœ… å¤±æ•—ã—ãŸã‚¿ã‚¹ã‚¯ãŒè‡ªå‹•çš„ã«ãƒªãƒˆãƒ©ã‚¤ã•ã‚Œã‚‹ (æœ€å¤§3å›ã¾ã§)
- âœ… ãƒªãƒˆãƒ©ã‚¤é–“ã«æŒ‡æ•°ãƒãƒƒã‚¯ã‚ªãƒ• (5ç§’ã€10ç§’ã€15ç§’)
- âœ… æœ€å¤§ãƒªãƒˆãƒ©ã‚¤å¾Œã€ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒãƒ‡ãƒƒãƒ‰ãƒ¬ã‚¿ã‚­ãƒ¥ãƒ¼ã«é€ã‚‰ã‚Œã‚‹
- âœ… ãƒ‡ãƒƒãƒ‰ãƒ¬ã‚¿ã‚­ãƒ¥ãƒ¼ã‚’ç›£è¦–ã—å†å®Ÿè¡Œå¯èƒ½

**æ™‚é–“**: 30-40åˆ†

---

### æ¼”ç¿’3: ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ã®å®Ÿè£… â­â­â­ (ä¸Šç´š)

**ç›®æ¨™**: å¤±æ•—ä¸­ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¸ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’åœæ­¢ã—ã€é€£é–çš„ãªå¤±æ•—ã‚’é˜²ãã€‚

**æ‰‹é †**:

1. **ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚¯ã‚¯ãƒ©ã‚¹ã‚’ä½œæˆ:**

```python
from enum import Enum
from datetime import datetime, timedelta

class CircuitState(Enum):
    CLOSED = "closed"      # é€šå¸¸ã®æ“ä½œ
    OPEN = "open"          # å¤±æ•—ã€ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’æ‹’å¦
    HALF_OPEN = "half_open"  # å›å¾©ã—ãŸã‹ãƒ†ã‚¹ãƒˆä¸­

class CircuitBreaker:
    def __init__(self, failure_threshold=5, timeout_seconds=60):
        self.failure_threshold = failure_threshold
        self.timeout_seconds = timeout_seconds
        self.failure_count = 0
        self.last_failure_time = None
        self.state = CircuitState.CLOSED
    
    def call(self, func):
        """Execute function with circuit breaker protection"""
        if self.state == CircuitState.OPEN:
            # ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆãŒåˆ‡ã‚ŒãŸã‹ç¢ºèª
            if datetime.utcnow() - self.last_failure_time > timedelta(seconds=self.timeout_seconds):
                self.state = CircuitState.HALF_OPEN
                print("ğŸ”„ Circuit breaker: HALF_OPEN (testing)")
            else:
                raise Exception(f"Circuit breaker OPEN for agent. Try again in {self.timeout_seconds}s")
        
        try:
            result = func()
            
            # æˆåŠŸ
            if self.state == CircuitState.HALF_OPEN:
                self.state = CircuitState.CLOSED
                self.failure_count = 0
                print("âœ… Circuit breaker: CLOSED (recovered)")
            
            return result
            
        except Exception as e:
            self.failure_count += 1
            self.last_failure_time = datetime.utcnow()
            
            if self.failure_count >= self.failure_threshold:
                self.state = CircuitState.OPEN
                print(f"ğŸ”´ Circuit breaker: OPEN (too many failures)")
            
            raise e
```

2. **ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆå‘¼ã³å‡ºã—ã«é©ç”¨:**

```python
# ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼å†…ã§
agent_circuits = {
    'web': CircuitBreaker(failure_threshold=5, timeout_seconds=60),
    'academic': CircuitBreaker(failure_threshold=5, timeout_seconds=60),
    'news': CircuitBreaker(failure_threshold=5, timeout_seconds=60),
    'social': CircuitBreaker(failure_threshold=5, timeout_seconds=60)
}

def send_to_agent(agent_type, message_data):
    """Send with circuit breaker protection"""
    circuit = agent_circuits[agent_type]
    
    try:
        circuit.call(lambda: send_message(agent_type, message_data))
    except Exception as e:
        print(f"âš ï¸ Skipping {agent_type} agent: {e}")
        # ä»–ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ç¶šè¡Œ
```

3. **ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ã‚’ãƒ†ã‚¹ãƒˆ:**

```bash
# ç¹°ã‚Šè¿”ã—ã®å¤±æ•—ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆã™ã‚‹ï¼ˆ1ã¤ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’åœæ­¢ï¼‰
az containerapp stop --name web-research-agent --resource-group rg-agents

# è¤‡æ•°ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’é€ä¿¡ã™ã‚‹
for i in {1..10}; do
  curl -X POST $ORCHESTRATOR_URL/research-parallel \
    -H "Content-Type: application/json" \
    -d '{"query": "test query '$i'"}'
  sleep 2
done

# ãƒ­ã‚°ã‚’ç¢ºèªã™ã‚‹ - 5å›ã®å¤±æ•—å¾Œã«å›è·¯ãŒé–‹ã„ã¦ã„ã‚‹ã¯ãš
azd logs orchestrator --tail 50
```

**âœ… æˆåŠŸåŸºæº–:**
- âœ… 5å›ã®å¤±æ•—å¾Œã€ã‚µãƒ¼ã‚­ãƒƒãƒˆãŒã‚ªãƒ¼ãƒ—ãƒ³ (ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’æ‹’å¦)
- âœ… 60ç§’å¾Œã€ã‚µãƒ¼ã‚­ãƒƒãƒˆãŒãƒãƒ¼ãƒ•ã‚ªãƒ¼ãƒ—ãƒ³ (å›å¾©ã‚’ãƒ†ã‚¹ãƒˆ)
- âœ… ä»–ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯é€šå¸¸é€šã‚Šå‹•ä½œ
- âœ… ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒå›å¾©ã™ã‚‹ã¨ã‚µãƒ¼ã‚­ãƒƒãƒˆãŒè‡ªå‹•çš„ã«ã‚¯ãƒ­ãƒ¼ã‚º

**æ™‚é–“**: 40-50åˆ†

---

## ç›£è¦–ã¨ãƒ‡ãƒãƒƒã‚°

### Application Insightsã‚’ä½¿ç”¨ã—ãŸåˆ†æ•£ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°

**ãƒ•ã‚¡ã‚¤ãƒ«: `src/shared/tracing.py`**

```python
from opencensus.ext.azure.log_exporter import AzureLogHandler
from opencensus.ext.azure.trace_exporter import AzureExporter
from opencensus.trace import config_integration
from opencensus.trace.tracer import Tracer
from opencensus.trace.samplers import AlwaysOnSampler
import logging
import os

# ãƒˆãƒ¬ãƒ¼ã‚¹ã‚’è¨­å®šã™ã‚‹
config_integration.trace_integrations(['requests', 'logging'])

connection_string = os.environ.get('APPLICATIONINSIGHTS_CONNECTION_STRING')

# ãƒˆãƒ¬ãƒ¼ã‚µãƒ¼ã‚’ä½œæˆã™ã‚‹
tracer = Tracer(
    exporter=AzureExporter(connection_string=connection_string),
    sampler=AlwaysOnSampler()
)

# ãƒ­ã‚®ãƒ³ã‚°ã‚’è¨­å®šã™ã‚‹
logger = logging.getLogger(__name__)
logger.addHandler(AzureLogHandler(connection_string=connection_string))
logger.setLevel(logging.INFO)

def trace_agent_call(agent_name, task_id, operation):
    """Trace agent operations"""
    with tracer.span(name=f'{agent_name}.{operation}') as span:
        span.add_attribute('agent', agent_name)
        span.add_attribute('task_id', task_id)
        span.add_attribute('operation', operation)
        
        try:
            result = operation()
            span.add_attribute('status', 'success')
            return result
        except Exception as e:
            span.add_attribute('status', 'error')
            span.add_attribute('error', str(e))
            raise
```

### Application Insightsã‚¯ã‚¨ãƒª

**ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã®è¿½è·¡:**

```kusto
// Trace complete workflow for a task
traces
| where customDimensions.task_id == "a1b2c3d4-..."
| project timestamp, message, customDimensions.agent, customDimensions.operation
| order by timestamp asc
```

**ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã®æ¯”è¼ƒ:**

```kusto
// Compare agent execution times
dependencies
| where name contains "agent"
| summarize 
    avg_duration = avg(duration),
    p95_duration = percentile(duration, 95),
    count = count()
  by agent = tostring(customDimensions.agent)
| order by avg_duration desc
```

**å¤±æ•—åˆ†æ:**

```kusto
// Find which agents fail most
exceptions
| where customDimensions.agent != ""
| summarize 
    failure_count = count(),
    unique_errors = dcount(outerMessage)
  by agent = tostring(customDimensions.agent)
| order by failure_count desc
```

---

## ã‚³ã‚¹ãƒˆåˆ†æ

### ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ ã®ã‚³ã‚¹ãƒˆ (æœˆé¡è¦‹ç©ã‚‚ã‚Š)

| ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ | æ§‹æˆ | ã‚³ã‚¹ãƒˆ |
|----------------|------|--------|
| **ã‚ªãƒ¼ã‚±ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¿ãƒ¼** | 1 Container App (1 vCPU, 2GB) | $30-50 |
| **4ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆ** | 4 Container Apps (0.5 vCPU, 1GB each) | $60-120 |
| **Service Bus** | Standard tier, 10M messages | $10-20 |
| **Cosmos DB** | Serverless, 5GB storage, 1M RUs | $25-50 |
| **Blob Storage** | 10GB storage, 100K operations | $5-10 |
| **Application Insights** | 5GB ingestion | $10-15 |
| **Azure OpenAI** | GPT-4, 10M tokens | $100-300 |
| **åˆè¨ˆ** | | **$240-565/æœˆ** |

### ã‚³ã‚¹ãƒˆæœ€é©åŒ–æˆ¦ç•¥

1. **å¯èƒ½ãªé™ã‚Šã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹ã‚’ä½¿ç”¨:**
   ```bicep
   // Cosmos DB serverless (no minimum cost)
   properties: {
     databaseAccountOfferType: 'Standard'
     capabilities: [{ name: 'EnableServerless' }]
   }
   ```

2. **ã‚¢ã‚¤ãƒ‰ãƒ«æ™‚ã«ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚’ã‚¼ãƒ­ã«ã‚¹ã‚±ãƒ¼ãƒ«:**
   ```bicep
   scale: {
     minReplicas: 0  // Scale to zero when no messages
     maxReplicas: 10
   }
   ```

3. **Service Busã§ãƒãƒƒãƒå‡¦ç†ã‚’ä½¿ç”¨:**
   ```python
   # ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ãƒãƒƒãƒã§é€ä¿¡ã™ã‚‹ï¼ˆã‚ˆã‚Šå®‰ä¾¡ï¼‰
   sender.send_messages([message1, message2, message3])
   ```

4. **é »ç¹ã«ä½¿ç”¨ã•ã‚Œã‚‹çµæœã‚’ã‚­ãƒ£ãƒƒã‚·ãƒ¥:**
   ```python
   # Azure Cache for Redis ã‚’ä½¿ç”¨ã™ã‚‹
   if cache.exists(query_hash):
       return cache.get(query_hash)
   ```

---

## ãƒ™ã‚¹ãƒˆãƒ—ãƒ©ã‚¯ãƒ†ã‚£ã‚¹

### âœ… æ¨å¥¨äº‹é …:

1. **å†ªç­‰æ€§ã®ã‚ã‚‹æ“ä½œã‚’ä½¿ç”¨**
   ```python
   # ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯åŒã˜ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¤‡æ•°å›å®‰å…¨ã«å‡¦ç†ã§ãã¾ã™
   def process_task(task_id):
       if state_manager.task_exists(task_id):
           print(f"Task {task_id} already processed, skipping")
           return
       # ã‚¿ã‚¹ã‚¯ã‚’å‡¦ç†ä¸­...
   ```

2. **åŒ…æ‹¬çš„ãªãƒ­ã‚°ã‚’å®Ÿè£…**
   ```python
   logger.info(f"Agent: {agent_name}, Task: {task_id}, Action: {action}")
   ```

3. **ç›¸é–¢IDã‚’ä½¿ç”¨**
   ```python
   # ã‚¿ã‚¹ã‚¯IDã‚’ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å…¨ä½“ã«æ¸¡ã™
   message_data = {
       'task_id': task_id,  # ç›¸é–¢ID
       'timestamp': datetime.utcnow().isoformat()
   }
   ```

4. **ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®TTL (æœ‰åŠ¹æœŸé™) ã‚’è¨­å®š**
   ```bicep
   properties: {
     defaultMessageTimeToLive: 'PT1H'  // 1 hour max
   }
   ```

5. **ãƒ‡ãƒƒãƒ‰ãƒ¬ã‚¿ã‚­ãƒ¥ãƒ¼ã‚’ç›£è¦–**
   ```python
   # å¤±æ•—ã—ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã®å®šæœŸçš„ãªç›£è¦–
   monitor_dead_letters()
   ```

### âŒ éæ¨å¥¨äº‹é …:

1. **å¾ªç’°ä¾å­˜ã‚’ä½œæˆã—ãªã„**
   ```python
   # âŒ æ‚ªã„: ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆA â†’ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆB â†’ ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆAï¼ˆç„¡é™ãƒ«ãƒ¼ãƒ—ï¼‰
   # âœ… è‰¯ã„: æ˜ç¢ºãªæœ‰å‘éå·¡å›ã‚°ãƒ©ãƒ•ï¼ˆDAGï¼‰ã‚’å®šç¾©ã™ã‚‹
   ```

2. **ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¹ãƒ¬ãƒƒãƒ‰ã‚’ãƒ–ãƒ­ãƒƒã‚¯ã—ãªã„**
   ```python
   # âŒ æ‚ªã„: åŒæœŸçš„ãªå¾…æ©Ÿ
   while not task_complete:
       time.sleep(1)
   
   # âœ… è‰¯ã„: ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚­ãƒ¥ãƒ¼ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’ä½¿ç”¨
   ```

3. **éƒ¨åˆ†çš„ãªå¤±æ•—ã‚’ç„¡è¦–ã—ãªã„**
   ```python
   # âŒ æ‚ªã„: 1ã¤ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒå¤±æ•—ã™ã‚‹ã¨ã€å…¨ä½“ã®ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãŒå¤±æ•—ã™ã‚‹
   # âœ… è‰¯ã„: ã‚¨ãƒ©ãƒ¼æŒ‡æ¨™ä»˜ãã§éƒ¨åˆ†çš„ãªçµæœã‚’è¿”ã™
   ```

4. **ç„¡é™ãƒªãƒˆãƒ©ã‚¤ã‚’ä½¿ç”¨ã—ãªã„**
@@CODE_BLOCK_48
## ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°ã‚¬ã‚¤ãƒ‰

### å•é¡Œ: ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒã‚­ãƒ¥ãƒ¼ã«æ»ç•™ã™ã‚‹

**ç—‡çŠ¶:**
- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒã‚­ãƒ¥ãƒ¼ã«æºœã¾ã‚‹
- ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒå‡¦ç†ã—ãªã„
- ã‚¿ã‚¹ã‚¯ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒã€Œä¿ç•™ã€ã®ã¾ã¾

**è¨ºæ–­:**
```bash
# ã‚­ãƒ¥ãƒ¼ã®æ·±ã•ã‚’ç¢ºèªã™ã‚‹
az servicebus queue show \
  --namespace-name mybus \
  --name research-tasks \
  --query "countDetails"

# ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®å¥åº·çŠ¶æ…‹ã‚’ç¢ºèªã™ã‚‹
azd logs research-agent --tail 50
```

**è§£æ±ºç­–:**

1. **ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®ãƒ¬ãƒ—ãƒªã‚«ã‚’å¢—ã‚„ã™:**
   ```bash
   az containerapp update \
     --name research-agent \
     --min-replicas 3 \
     --max-replicas 10
   ```

2. **ãƒ‡ãƒƒãƒ‰ãƒ¬ã‚¿ãƒ¼ã‚­ãƒ¥ãƒ¼ã‚’ç¢ºèªã™ã‚‹:**
   ```bash
   az servicebus queue show \
     --namespace-name mybus \
     --name research-tasks \
     --query "countDetails.deadLetterMessageCount"
   ```

---

### å•é¡Œ: ã‚¿ã‚¹ã‚¯ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã™ã‚‹/å®Œäº†ã—ãªã„

**ç—‡çŠ¶:**
- ã‚¿ã‚¹ã‚¯ã®ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãŒã€Œé€²è¡Œä¸­ã€ã®ã¾ã¾
- ä¸€éƒ¨ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã¯å®Œäº†ã™ã‚‹ãŒã€ä»–ã¯å®Œäº†ã—ãªã„
- ã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãŒè¡¨ç¤ºã•ã‚Œãªã„

**è¨ºæ–­:**
```bash
# ã‚¿ã‚¹ã‚¯ã®çŠ¶æ…‹ã‚’ç¢ºèªã™ã‚‹
curl $ORCHESTRATOR_URL/task/$TASK_ID

# Application Insightsã‚’ç¢ºèªã™ã‚‹
# ã‚¯ã‚¨ãƒªã‚’å®Ÿè¡Œã™ã‚‹: traces | where customDimensions.task_id == "..."
```

**è§£æ±ºç­–:**

1. **ã‚¢ã‚°ãƒªã‚²ãƒ¼ã‚¿ãƒ¼ã«ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’å®Ÿè£…ã™ã‚‹ (æ¼”ç¿’1)**

2. **ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã®éšœå®³ã‚’ç¢ºèªã™ã‚‹:**
   ```bash
   azd logs --follow | grep "ERROR\|FAIL"
   ```

3. **ã™ã¹ã¦ã®ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãŒç¨¼åƒã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹:**
   ```bash
   az containerapp list \
     --resource-group rg-agents \
     --query "[].{name:name, status:properties.runningStatus}"
   ```

---

## è©³ã—ãå­¦ã¶

### å…¬å¼ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
- [Azure Service Bus](https://learn.microsoft.com/azure/service-bus-messaging/service-bus-messaging-overview)
- [Cosmos DB](https://learn.microsoft.com/azure/cosmos-db/introduction)
- [Container Apps DAPR](https://learn.microsoft.com/azure/container-apps/dapr-overview)
- [ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆãƒ‡ã‚¶ã‚¤ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³](https://learn.microsoft.com/azure/architecture/guide/ai/multi-agent-systems)

### ã“ã®ã‚³ãƒ¼ã‚¹ã®æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—
- â† å‰: [ã‚­ãƒ£ãƒ‘ã‚·ãƒ†ã‚£ãƒ—ãƒ©ãƒ³ãƒ‹ãƒ³ã‚°](capacity-planning.md)
- â†’ æ¬¡: [SKUé¸æŠ](sku-selection.md)
- ğŸ  [ã‚³ãƒ¼ã‚¹ãƒ›ãƒ¼ãƒ ](../../README.md)

### é–¢é€£ä¾‹
- [ãƒã‚¤ã‚¯ãƒ­ã‚µãƒ¼ãƒ“ã‚¹ã®ä¾‹](../../../../examples/microservices) - ã‚µãƒ¼ãƒ“ã‚¹é€šä¿¡ãƒ‘ã‚¿ãƒ¼ãƒ³
- [Azure OpenAIã®ä¾‹](../../../../examples/azure-openai-chat) - AIçµ±åˆ

---

## ã¾ã¨ã‚

**å­¦ã‚“ã ã“ã¨:**
- âœ… 5ã¤ã®ã‚³ãƒ¼ãƒ‡ã‚£ãƒãƒ¼ã‚·ãƒ§ãƒ³ãƒ‘ã‚¿ãƒ¼ãƒ³ (é †æ¬¡ã€ä¸¦åˆ—ã€éšå±¤å‹ã€ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•å‹ã€ã‚³ãƒ³ã‚»ãƒ³ã‚µã‚¹)
- âœ… Azureã§ã®ãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ (Service Bus, Cosmos DB, Container Apps)
- âœ… åˆ†æ•£ã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆé–“ã®çŠ¶æ…‹ç®¡ç†
- âœ… ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆå‡¦ç†ã€ãƒªãƒˆãƒ©ã‚¤ã€ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼
- âœ… åˆ†æ•£ã‚·ã‚¹ãƒ†ãƒ ã®ç›£è¦–ã¨ãƒ‡ãƒãƒƒã‚°
- âœ… ã‚³ã‚¹ãƒˆæœ€é©åŒ–æˆ¦ç•¥

**é‡è¦ãªãƒã‚¤ãƒ³ãƒˆ:**
1. **é©åˆ‡ãªãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’é¸ã¶** - é †æ¬¡ã¯é †åºãŒå¿…è¦ãªãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã«ã€ä¸¦åˆ—ã¯é€Ÿåº¦é‡è¦–ã€ã‚¤ãƒ™ãƒ³ãƒˆé§†å‹•å‹ã¯æŸ”è»Ÿæ€§é‡è¦–
2. **çŠ¶æ…‹ã‚’æ…é‡ã«ç®¡ç†ã™ã‚‹** - Cosmos DBãªã©ã‚’ä½¿ç”¨ã—ã¦å…±æœ‰çŠ¶æ…‹ã‚’ç®¡ç†
3. **éšœå®³ã‚’å„ªé›…ã«å‡¦ç†ã™ã‚‹** - ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã€ãƒªãƒˆãƒ©ã‚¤ã€ã‚µãƒ¼ã‚­ãƒƒãƒˆãƒ–ãƒ¬ãƒ¼ã‚«ãƒ¼ã€ãƒ‡ãƒƒãƒ‰ãƒ¬ã‚¿ãƒ¼ã‚­ãƒ¥ãƒ¼
4. **ã™ã¹ã¦ã‚’ç›£è¦–ã™ã‚‹** - åˆ†æ•£ãƒˆãƒ¬ãƒ¼ã‚·ãƒ³ã‚°ã¯ãƒ‡ãƒãƒƒã‚°ã«ä¸å¯æ¬ 
5. **ã‚³ã‚¹ãƒˆã‚’æœ€é©åŒ–ã™ã‚‹** - ã‚¼ãƒ­ã‚¹ã‚±ãƒ¼ãƒ«ã€ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹ã€ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã®å®Ÿè£…

**æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—:**
1. å®Ÿè·µæ¼”ç¿’ã‚’å®Œäº†ã™ã‚‹
2. è‡ªåˆ†ã®ãƒ¦ãƒ¼ã‚¹ã‚±ãƒ¼ã‚¹ã«åˆã‚ã›ãŸãƒãƒ«ãƒã‚¨ãƒ¼ã‚¸ã‚§ãƒ³ãƒˆã‚·ã‚¹ãƒ†ãƒ ã‚’æ§‹ç¯‰ã™ã‚‹
3. [SKUé¸æŠ](sku-selection.md)ã‚’å­¦ã³ã€ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¨ã‚³ã‚¹ãƒˆã‚’æœ€é©åŒ–ã™ã‚‹

---

<!-- CO-OP TRANSLATOR DISCLAIMER START -->
**å…è²¬äº‹é …**:  
ã“ã®æ–‡æ›¸ã¯ã€AIç¿»è¨³ã‚µãƒ¼ãƒ“ã‚¹[Co-op Translator](https://github.com/Azure/co-op-translator)ã‚’ä½¿ç”¨ã—ã¦ç¿»è¨³ã•ã‚Œã¦ã„ã¾ã™ã€‚æ­£ç¢ºæ€§ã‚’æœŸã™ã‚ˆã†åŠªã‚ã¦ãŠã‚Šã¾ã™ãŒã€è‡ªå‹•ç¿»è¨³ã«ã¯èª¤ã‚Šã‚„ä¸æ­£ç¢ºãªéƒ¨åˆ†ãŒå«ã¾ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚åŸæ–‡ï¼ˆå…ƒã®è¨€èªã§è¨˜è¼‰ã•ã‚ŒãŸæ–‡æ›¸ï¼‰ã‚’ä¿¡é ¼ã§ãã‚‹æƒ…å ±æºã¨ã—ã¦ã”å‚ç…§ãã ã•ã„ã€‚é‡è¦ãªæƒ…å ±ã«ã¤ã„ã¦ã¯ã€å°‚é–€ã®äººé–“ã«ã‚ˆã‚‹ç¿»è¨³ã‚’ãŠå‹§ã‚ã—ã¾ã™ã€‚æœ¬ç¿»è¨³ã®ä½¿ç”¨ã«èµ·å› ã™ã‚‹èª¤è§£ã‚„èª¤èªã«ã¤ã„ã¦ã€å½“æ–¹ã¯ä¸€åˆ‡ã®è²¬ä»»ã‚’è² ã„ã‹ã­ã¾ã™ã€‚
<!-- CO-OP TRANSLATOR DISCLAIMER END -->